---
layout: post
title: "C++类的深入"
date: 2016-8-31
desc: "C++类的深入"
keywords: "C++,class"
categories: [Database]
tags: [C++,class]
---

面向对象的基础就是**类的定义已经对象的创建**，C++中尤其重要，
C++中，**类的默认权限为私有，结构体为公有**。

### 类对象在内存中的分布
在类中，只有数据成员占内存空间，成员函数主要分布在代码段中，一般对象所占的内存空间大小为  
sizeof(成员1) + sizeof(成员2) + sizeof(成员3) + ...，但也有几种特殊情况：  
**虚函数和继承、空类、内存对齐、静态数据成员。**  
只要出现虚函数就会多出**4个字节**的空间，作为虚函数表，继承时需要考虑基类的大小，  
出现静态成员时，静态成员存在于数据段中，并不在类对象的空间中。

* 空类应该不占用内存，但实际却不是这样：  

``` c++
class Test{
public:
	int Print(){
    	printf("Hello World\n");
    }
};

int main(){
	Test m_Test;
    
    printf("%d\n",sizeof(m_Test));
}
```

程序运行会发现输出为**1**，如上所说，空类中没有数据成员，应该不占内存空间，但我们知道  
每个类都有一个this指针指向具体的内存，以便成员函数调用，即使定义一个类什么都不写，  
编译器也会提供默认的构造函数初始化这个类，但是类的实例不占内存空间，该如何初始化呢？  
所以编译器分配一个**1字节**的空间初始化this指针，故**空类占一个字节**。

* 内存对齐

``` c++
class Test{
public:
	short s;
    int n;
};
```

在程序中定义这样一个类，通过 sizeof()得到的实例大小为**8**，又不满足如上了，  
我们知道**为了程序效率，编译器并不会依次申请内存存储变量，而采取内存对齐的方式，以牺牲一定内存空间的代价来换取程序的效率**，  
该类的大小为8，就是**内存对齐**的结果。  
通过调试查看类各个成员的内存地址发现(VC++ 6.0)，**n**的地址是 0x0012ff44，**s**的地址是 0x0012ff40，s 应该占用2个字节，但是n并未出现在 0x0012ff42 的位置。  
假设编译器默认采用n个字节对齐方式(VC++ 6.0默认采用8字节对齐方式)，而类中某个成员实际占用空间大小为m，那么该成员的内存地址必须是 **p的整数倍，p = min(m,n)**，  
所以对 s 来说，采用2字节对齐方式，分配到的首地址0x0012ff40是2的倍数，n采用4字节对齐方式，所以分配给n的内存首地址应该为4的倍数，所以其取0x0012ff44作为首地址，故该类占用8个字节。  

``` c++

```
